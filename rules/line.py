"""Point Structure."""
from rules.drawable import *
lineADT = {
    is_a:tuple(),
    "new":{
        tuple():{
            args:tuple(),
            trgt:Line.default
        },
        (str,):{
            args:("parallelAxis",),
            trgt:Line.default
        },
        (Point,Point,):{
            args:("point1","point2"),
            trgt:Line.fromPoints,
        },
        (float,float,Point,):{
            args:("angle","length","point",),
            trgt:Line.fromMetrics,
        },
        retVal:Point
    },
    "copy":{
        tuple():{
            args:tuple(),
            trgt:Line.fromLine
        },
        retVal:Line
    },
    "angle":{
        tuple():{
            args:tuple(),
            trgt:Line.angle
        },
        retVal:float
    },
    "length":{
        tuple():{
            args:tuple(),
            trgt:Line.length
        },
        retVal:float
    },
    "distanceFrom":{
        (Line,):{
            args:("line",),
            trgt:Line.distanceFrom
        },
        (Point,):{
            args:("point",),
            trgt:Line.distanceFrom
        },
        retVal:float
    },
    "bisector":{
        tuple():{
            args:tuple(),
            trgt:Line.bisector
        },
        retVal:Point
    },
    "sector":{
        (float, float,):{
            args:("m", "n",),
            trgt:Line.sector
        },
        retVal:Point
    },
    "intersect":{
        (Line,):{
            args:("line",),
            trgt:Line.intersectionWith
        },
        retVal:Point
    },
    "parallelLine":{
        (Point,):{
            args:("point",),
            trgt:Line.parallelLine
        },
        (float,):{
            args:("distance",),
            trgt:Line.parallelLine
        },
        retVal:Point
    },
    "projectionOf":{
        (Point,):{
            args:("point",),
            trgt:Line.projectionOf
        },
        retVal:Point
    },
    "perpendicularFrom":{
        (Point,):{
            args:("point",),
            trgt:Line.perpendicularFrom
        },
        retVal:Line
    },
    "perpendicularAt":{
        (Point,):{
            args:("point",),
            trgt:Line.perpendicularAt
        },
        (float,):{
            args:("ratio",),
            trgt:Line.perpendicularAt
        },
        retVal:Line
    },
    "perpendicularBisector":{
        tuple():{
            args:tuple(),
            trgt:Line.perpendicularBisector
        },
        retVal:Line
    },
    "triangle":{
        (Point,):{
            args:("point",),
            trgt:Line.triangleTo
        },
        retVal:Triangle
    },
    "circle":{
        tuple():{
            args:tuple(),
            trgt:Line.circleAround
        },
        retVal:Circle
    },
    "tangentCircle":{
        (Point,):{
            args:("tangentPoint",),
            trgt:Line.circleAround
        },
        retVal:Circle
    },
    "chordCircle":{
        (Point,):{
            args:("chordPoint",),
            trgt:Line.circleAround
        },
        retVal:Circle
    },
    "quad":{
        (str,):{
            args:("direction",),
            trgt:Line.square
        },
        retVal:int
    },#TODO
    "rectangle":{
        (float, str,):{
            args:("sideLength", "direction"),
            trgt:Line.rectangle
        },
        retVal:int
    }#TODO
}